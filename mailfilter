#!/usr/bin/perl -w

use strict;
use Mail::Audit;
use Time::JulianDay;
use Getopt::Long;

my %option;
GetOptions(\%option,
	   "file=s",
	   "check",
	   "mailfolder=s",
	  );

# FIX: make TO be all recipients.

# My Mail Policies:
#
# 0) Until trust for this gets built up, we will be saving EVERYTHING 
#    to a single file and logging what we WOULD have done.
# 1) Go through my general filter list, deal w/ matches as directed.
#    this will deal w/ know email addresses, email lists, etc.
#
#    All that should be left is:
#      + real spam
#      + suspect spam
#      + addresses I need to add to my list
#
# 2) If the mail fails rblcheck, it is real spam and goes to BlackBox
# 3) All other mail goes to GrayBox

$option{mailfolder} = (getpwuid($>))[7] . "/Mail"
  unless $option{mailfolder};

(&log("'$option{mailfolder}' is not a valid directory"), exit(1))
  unless -d $option{mailfolder};

open LOG, ">>/home/ryand/.mailfilter.log"
  || die "Couldn't open mailfilter.log: $!";

# Get all of our standard fields of interest.
my ($item, $from, $to, $cc, $subject);
unless ($option{check}) {
  $item = Mail::Audit->new();
  $from = $item->from();
  $to = $item->to();
  $cc = $item->cc();
  $subject = $item->subject();
  chomp($from, $to, $cc, $subject);
  study $from;
}

# general filter
my $isodate_re = '\d{4}-\d{2}-\d{2}';
my $field_re = 'SUBJECT|FROM|TO|CC';

if ($option{file}) {
  unless (open IN, $option{file}) {
    &log("Error opening recipe file '$option{file}': $!");
    exit(1);
  } 
} else {
  *IN = *DATA;
}

while (<IN>) {

  # the usual whitespace cleanup
  chomp;
  s/^\s+//;
  s/\s+$//;

  # ignore comment lines
  next if m/^\#/;
  next if m/^$/;

  my ($cmd, $action, $file, $isodate, $field, $regex, $msg) 
    = ('save', '', '', '', '', '', '');

  if (m/^ACCEPT\s+(\S+)(?:\s+($isodate_re))?\s+($field_re)\s+(.+)/o) {
    $file = $1;
    $isodate = $2 || '';
    $field = lc($3);
    $regex = $4;
    $msg = '';
  } elsif (m/^IGNORE\s+(?:\s+($isodate_re)\s+)?($field_re)\s+(.+)/o) {
    $file = 'BlackBox';
    $isodate = $1 || '';
    $field = lc($2);
    $regex = $3;
    $msg = "Ignoring";
  } elsif (m/^EXEC\s+(\S+)\s+($field_re)\s+(.+)/o) {
    $cmd = 'run';
    $file = $1;
    $field = lc($2);
    $regex = $3;
  } else {
    &log("ERROR: syntax error: '$_'");
    exit(1);
  }

  if ($isodate) {
    $isodate =~ /(\d\d\d\d)-(\d\d)-(\d\d)/;
    my $then = julian_day($1, $2, $3);
    my $now  = local_julian_day(time);

    if ($then < $now) {
      &log("Skipping $field/$regex/$isodate ($then < $now)");
      next;
    }
  }

  unless ($option{check}) {
    my $cmd = "&$cmd(\$file, \$msg, \$field, \$$field, \$regex) if \$$field =~ $regex";
    eval $cmd;
    if ($@) {
      &log("ERROR w/ '$cmd': $@");
    }
  } else {
    &log($file, $msg, $field, $regex);
    my $cmd = "'blah' =~ $regex";
    eval $cmd;
    if ($@) {
      &log("ERROR w/ '$cmd': $@");
      exit(1);
    }
  }
}

unless ($option{check}) {
  my $rbl = $item->rblcheck(5);
  if ($rbl) {
    &save("BlackBox", "SPAM: '$rbl'");
  } else {
    &save("GrayBox", "Default rule");
  }
} else {
  &log("Looks good");
}

sub run {
  my $file = shift;

  &log("Running $file");

  $SIG{CHLD} = 'IGNORE';
  unless (fork()) {
    system $file || die "$?";
    exit(0);
  }
}

sub save {
  my $box = shift;

  &log("Saving in '$box'", @_);
  $item->accept("$option{mailfolder}/$box");
}

sub log {
  my $msg = join(': ', @_);

  use Date::Format;
  my $time = time2str("%Y%m%d_%H%M%S", time);

  unless ($option{check}) {
    print LOG "$time: $from: $subject: $msg\n";
  } else {
    print "$msg\n";
  }
}

__DATA__
# FORMAT:
# ACCEPT FILE [ISODATE] FIELD REGEX
# IGNORE      [ISODATE] FIELD REGEX
#
# FILE    = some/path (already in mail folder)
# ISODATE = YYYY-MM-DD
# FIELD   = (SUBJECT|FROM|TO|CC)
# REGEX   = any perl regex
#
# EXAMPLES:
#
# Ignores any mail whose subject has "Alec Guiness" in it until 2000-09-01
# IGNORE 2000-09-01 SUBJECT m/Alec Guiness/
#
# Accepts mail from "fred@domain.com" into "Personal/Fred"
# ACCEPT Personal/Fred FROM m/fred@domain.com/
#

#CMD   FILE          ISODATE    FIELD   REGEX
