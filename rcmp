#!/usr/bin/perl -w

use strict;
use Digest::MD5;
use Getopt::Long;
use Data::Dumper;
use File::Basename;
$Data::Dumper::Indent = 1;

my %option = ();
GetOptions(\%option,
	   "no",
	   "rm",
	   "cp",
	   "mv",
	   "diff",
	   "report",
	   "debug",
	  );

$option{report} = 1
  unless $option{cp} || $option{rm} || $option{diff};

# rm files from B that are the same
# cp files from B that are different or missing in A
# diff files that are different

my $aDirBase = shift;
my $bDirBase = shift;
my $aMD5 = {};
my $bMD5 = {};
my $cmp  = {};

unless (
	defined $aDirBase &&
	defined $bDirBase &&
	-d $aDirBase &&
	-d $bDirBase
       ) {
  print "USAGE: FIX\n";
  exit 1;
}

&scan;
&compare;
&debug, exit(1)  if $option{debug};
&diff   if $option{diff};
&copy   if $option{cp};
&remove if $option{rm};
&report if $option{report};
exit(0);

sub debug {
  print Dumper($cmp);
}

sub scan {
  print "Scanning $aDirBase\n";
  $aMD5 = &rmd5($aDirBase);
  print "Scanning $bDirBase\n";
  $bMD5 = &rmd5($bDirBase);
}

sub compare {
  print "Comparing results\n";
  $cmp = &cmpHash($aMD5, $bMD5);
}

sub run {
  my $cmd = join(' ', @_);

  if ($option{no}) {
    print "$cmd\n";
  } else {
    my $status = system $cmd;
    #die "Problem running '$cmd' ($?): $!" if $status;
  }
}

sub countDirContents {
  my $path = shift;
  my $count = 0;
  die "'$path' is not a directory" unless -d $path;

  opendir DIR, $path || die "Couldn't open '$path': $!";
  foreach my $file (readdir DIR) {
    next if $file =~ m/^\.\.?$/;
    $count++;
  }
  closedir DIR;

  return $count;
}

sub pruneDir {
  my $dir = shift;
  die "'$dir' is not a directory" unless -d $dir;

  if (countDirContents($dir) == 0) {
    run "rm -rf $dir";
    pruneDir(dirname $dir);
  }
}

sub diff {
  foreach (@{$cmp->{diff}}) {
    print "-" x 70, "\n" unless $option{no};
    run "diff -c $aDirBase$_ $bDirBase$_";
  }
}

sub copy {
  foreach (@{$cmp->{diff}}) {
    run "cp $bDirBase$_ $aDirBase$_";
  }
  foreach (@{$cmp->{notA}}) {
    run "cp $bDirBase$_ $aDirBase$_";
  }
}

sub remove {
  foreach (@{$cmp->{same}}) {
    run "rm -f $bDirBase$_";
    pruneDir(dirname "$bDirBase$_");
  }
}

sub report {
  my %data = ();

  foreach (@{$cmp->{notA}}) { $data{$_} = '>'; }
  foreach (@{$cmp->{notB}}) { $data{$_} = '<'; }
  foreach (@{$cmp->{same}}) { $data{$_} = '='; }
  foreach (@{$cmp->{diff}}) { $data{$_} = '~'; }
  
  foreach (sort keys %data) {
    print "$data{$_} $_\n";
  }
}

# given a path to a directory, returns a hash of all enclosed files w/ MD5s
sub rmd5 {
  my $path = shift || die "Need a path";
  die "$path must be a directory" unless -d $path;

  my %result = ();
  my @dirs  = ($path);

  while (@dirs) {
    my $dir = shift @dirs;
    opendir DIR, $dir;

    foreach my $file (readdir DIR) {
      next if $file =~ m/^\.\.?$/;

      $file = "$dir/$file";

      if (-d $file) {
	push @dirs, "$file";
      } elsif (-f $file) {

	my $digest = Digest::MD5->new;
	open IN, $file || warn "$!", next;
	$digest->addfile(\*IN);

	$file =~ s/^$path//;
	$result{$file} = $digest->hexdigest;

      } else {
	print "UNKNOWN TYPE: $file\n";
      }
    }
    
    closedir DIR;
  }

  return \%result;
}

sub cmpHash {

  my $a = shift;
  my $b = shift;
  my @notB = ();
  my @notA = ();
  my @same = ();
  my @diff = ();

  # find all common keys and things not in B
  foreach my $key (keys %$a) {
    if (exists $b->{$key}) {
      if ($a->{$key} eq $b->{$key}) {
	push @same, $key;
      } else {
	push @diff, $key;
      }
    } else {
      push @notB, $key;
    }
  }

  # find all things not in A
  foreach my $key (keys %$b) {
    unless (exists $a->{$key}) {
      push @notA, $key;
    }
  }

  @notB = sort @notB;
  @notA = sort @notA;
  @same = sort @same;
  @diff = sort @diff;

  return {
	  same => \@same,
	  diff => \@diff,
	  notA => \@notA,
	  notB => \@notB,
	 };
}
